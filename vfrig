#!/usr/bin/env python

"""

vfrig is the top-level Python script which begins a specified set of verification tasks.

The tasks are controlled through command options defined in vfr/options.py and a collection
of measurement parameters defined in vfr/conf.py.

The "metascript" logic, which converts high-level instructions into a sequence of pre-defined
measurement and evaluation tasks, is defined in vfr/TaskLogic.py and vfr/task_config.py.
The list of tasks to be carried out is extracted from the command line options. The user can
request a high-level task or a low-level task. Each high-level task is resolved into a
series of low-level tasks by the task logic functions. Finally, this script makes a series
of choices of the form

	if T.<task_name> in tasks:
		<run the task>

to decide whether to run each task. Note that the tasks are executed in the order defined
within this script, not the order contained within the "tasks" list.

Low-level functions common to most tests may be found in vfr/tests_common.py.

See vfrig-help and vfr/helptext.py for information.

"""

from __future__ import absolute_import, division, print_function

import sys
from argparse import Namespace
import logging
from vfr.auditlog import configure_logs, get_fpuLogger, add_email_handler
from vfr.rig import Rig

# Common collections of configuration parameters.
from vfr.conf import (
    COLLDECT_MEASUREMENT_PARS,
    DATUM_REP_ANALYSIS_PARS,
    DATUM_REP_MEASUREMENT_PARS,
    VERIFICATION_ROOT_FOLDER,
    MET_CAL_CAMERA_IP_ADDRESS,
    MET_CAL_FIBRE_ANALYSIS_PARS,
    MET_CAL_MEASUREMENT_PARS,
    MET_CAL_TARGET_ANALYSIS_PARS,
    MET_HEIGHT_ANALYSIS_PARS,
    MET_HEIGHT_CAMERA_IP_ADDRESS,
    MET_HEIGHT_EVALUATION_PARS,
    MET_HEIGHT_MEASUREMENT_PARS,
    POS_REP_ANALYSIS_PARS,
    POS_REP_CAMERA_IP_ADDRESS,
    POS_REP_EVALUATION_PARS,
    POS_REP_MEASUREMENT_PARS,
    POS_VER_EVALUATION_PARS,
    POS_VER_MEASUREMENT_PARS,
    PUP_ALGN_ANALYSIS_PARS,
    PUP_ALGN_CAMERA_IP_ADDRESS,
    PUP_ALGN_EVALUATION_PARS,
    PUP_ALGN_MEASUREMENT_PARS,
    REWIND_POS_ALPHA,
    REWIND_POS_BETA,
)

# Connection functions.
from vfr.connection import check_can_connection, check_connection

# Database management functions.
from vfr.db.snset import add_sns_to_set
from vfr.db.toplevel import Database
from vfr.options import parse_args, check_sns_unique
from vfr.posdb import init_position

# Task management functions.
from vfr.TaskLogic import T, resolve
from vfr.task_config import MEASUREMENT_TASKS

# Common measurement functions.
from vfr.tests_common import (
    find_datum,
    flush,
    cd_to_data_root,
    set_quit_handler,
    safe_home_turntable,
)

# Functional test functions and parameters.
from vfr.verification_tasks.functional_tests import (
    DASEL_ALPHA,  # Datum alpha only selection flag
    DASEL_BETA,   # Datum beta only selection flag
    DASEL_BOTH,   # Datum alpha and beta together selection flag
    rewind_fpus,  # Move FPUs close to datum, ready for a findDatum to be executed
    test_datum,
    test_limit,
)

# Datum repeatability test functions
from vfr.verification_tasks.measure_datum_repeatability import (
    eval_datum_repeatability,
    measure_datum_repeatability,
)

# Metrology height calibration functions
from vfr.verification_tasks.metrology_calibration import (
    eval_metrology_calibration,
    measure_metrology_calibration,
)
from vfr.verification_tasks.metrology_height import (
    eval_metrology_height,
    measure_metrology_height,
)

# Positional repeatability and gearbox calibration functions
from vfr.verification_tasks.positional_repeatability import (
    eval_positional_repeatability,
    measure_positional_repeatability,
    eval_gearbox_calibration,
)
from vfr.verification_tasks.positional_repeatability_check import (
    measure_positional_repeatability_check,
)

# Positional verification test functions
from vfr.verification_tasks.positional_verification import (
    eval_positional_verification,
    measure_positional_verification,
)

# Pupil alignment test functions
from vfr.verification_tasks.pupil_alignment import (
    eval_pupil_alignment,
    measure_pupil_alignment,
)

# Plotting and reporting functions
from vfr.output.report import dump_data, report
from vfr.output.plotting import plot

# Self-test functions
from vfr.verification_tasks.rig_selftest import selftest_fibre, selftest_nonfibre

#--------------------------------------------------------------------------------
if __name__ == "__main__":
    # Collect command line options and parameters.
    opts, db_opts, rig_opts = parse_args()

    # Load FPU information from the specified database.
    # Also load rig configuration information from the specified setup file.
    # Measurement tasks can be performed only on FPUs declared to be installed
    # on the rig. Evaluation tasks can be performance on any FPU registered
    # in the database.
    dbe = Database(opts=db_opts)
    fpu_config, measure_fpuset, eval_fpuset = dbe.load_fpu_config_and_sets(
        opts.setup_file, opts
    )

    # Configure logging.
    configure_logs(measure_fpuset, fpu_config, opts.loglevel)
    logger = logging.getLogger("")

	# Extract the initial list of tasks and options from the command line.
    logger.info("Starting verification")
    logger.info("vfrig command line tasks = %r" % opts.tasks)
    logger.debug("vfrig command line options = %r" % opts)
    logger.trace("vfrig database options = %r" % db_opts)
    logger.trace("vfrig rig options = %r" % rig_opts)

    logger.debug("FPUs in measurement set: %s" % str(measure_fpuset))
    logger.debug("FPUs in evaluation set: %s" % str(eval_fpuset))

    try:
        try:
            #
            # Initialise operations and connect to the rig hardware.
            #
            rig_params = Namespace(measure_fpuset=measure_fpuset, opts=rig_opts)

            # Change current directory to image root folder, so that
            # we can use relative image paths in both measurement
            # and evaluation tasks
            cd_to_data_root(VERIFICATION_ROOT_FOLDER)

            # Resolve high-level tasks and dependent checks and measurements into
            # low-level actions. (opts.tasks contains the tasks requested by the
            # user and tasks contains the list of low-level actions derived from
            # the task logic).
            tasks = resolve(opts.tasks, rig_params, dbe)

            if not rig_params.measure_fpuset:  # pylint: disable=no-member
                # no measurements, we remove all related tasks
                logger.info("No FPUs in measurement set. Removing all measurement tasks.")
                tasks -= MEASUREMENT_TASKS

            if tasks & MEASUREMENT_TASKS:
                # we are going to need the rig hardware
                rig = Rig(rig_params, fpu_config=fpu_config)

            if opts.expand_tasks:
                logger.info("Expanded tasks: %s" % list(tasks))
                sys.exit(0)
            #
            # Begin with connection testing tasks.
            #
            # Check connections to cameras and EtherCAN gateway
            logger.info("----------------------------------------------------------------------")
            if T.TST_GATEWAY_CONNECTION in tasks:
                logger.info("[%s] ###" % T.TST_GATEWAY_CONNECTION)
                check_connection(opts, "gateway", opts.gateway_address)

            if T.TST_POS_REP_CAM_CONNECTION in tasks:
                logger.info("[%s] ###" % T.TST_POS_REP_CAM_CONNECTION)
                if opts.mockup:
                    logger.info("Skipping test...")
                else:
                    check_connection(
                        opts,
                        "positional repeatability camera",
                        POS_REP_CAMERA_IP_ADDRESS,
                    )

            if T.TST_MET_CAL_CAM_CONNECTION in tasks:
                logger.info("[%s] ###" % T.TST_MET_CAL_CAM_CONNECTION)
                if opts.mockup:
                    logger.info("Skipping test...")
                else:
                    check_connection(
                        opts, "metrology calibration camera", MET_CAL_CAMERA_IP_ADDRESS
                    )

            if T.TST_MET_HEIGHT_CAM_CONNECTION in tasks:
                logger.info("[%s] ###" % T.TST_MET_HEIGHT_CAM_CONNECTION)
                if opts.mockup:
                    logger.info("Skipping test...")
                else:
                    check_connection(
                        opts, "metrology height camera", MET_HEIGHT_CAMERA_IP_ADDRESS
                    )

            if T.TST_PUP_ALGN_CAM_CONNECTION in tasks:
                logger.info("[%s] ###" % T.TST_PUP_ALGN_CAM_CONNECTION)
                if opts.mockup:
                    logger.info("Skipping test...")
                else:
                    check_connection(
                        opts, "pupil alignment camera", PUP_ALGN_CAMERA_IP_ADDRESS
                    )

            if T.TASK_INIT_RD in tasks:

                logger.info("[initialize unprotected FPU driver] ###")
                rig.init_driver(protected=False)

            if T.TST_CAN_CONNECTION in tasks:
                logger.info("[test_can_connection] ###")
                for fpu_id in range(opts.N):
                    fpu_audit = get_fpuLogger(fpu_id, fpu_config, __name__).audit

                    fpu_audit(
                        "Checking CAN connection for FPU at CAN ID %i... " % fpu_id
                    )

                    rv = check_can_connection(rig.rd, rig.grid_state, rig.opts, fpu_id)
                    fpu_audit(
                        "Checking CAN connection for FPU at CAN ID %i... %r"
                        % (fpu_id, rv)
                    )
            #
            # Flash the serial numbers if needed.
            #
            if T.TST_FLASH in tasks:
                logger.info("[flash_snum] ###")
                check_sns_unique(rig, dbe)
                flashed_numbers = []
                for fpu_id in measure_fpuset:
                    fpu_info = get_fpuLogger(fpu_id, fpu_config, __name__).info
                    serial_number = fpu_config[fpu_id]["serialnumber"]
                    fpu_info(
                        "Flashing FPU #%i with serial number %r ... "
                        % (fpu_id, serial_number)
                    )
                    rval = rig.rd.writeSerialNumber(
                        fpu_id, serial_number, rig.grid_state
                    )
                    flashed_numbers.append(serial_number)
                    fpu_info(
                        "Flashing FPU #%i with serial number %r ... %r"
                        % (fpu_id, serial_number, rval)
                    )
                    rig.rd.readSerialNumbers(rig.grid_state)
                # we update the set of FPUs which are in the database,
                # so that we can iterate over existing data when generating reports.
                add_sns_to_set(dbe, flashed_numbers)

            if T.TST_INITPOS in tasks:
                logger.info("[init_positions] ###")

                for fpu_id in measure_fpuset:
                    alpha_start, beta_start = fpu_config[fpu_id]["pos"]
                    serialnumber = fpu_config[fpu_id]["serialnumber"]

                    init_position(dbe, fpu_id, serialnumber, alpha_start, beta_start)

            # switch to protected driver instance, if needed

            set_quit_handler()

            logger.info("----------------------------------------------------------------------")
            if T.TASK_INIT_GD in tasks:

                logger.info("[initialize protected driver] ###")
                rig.init_driver(env=dbe.env, protected=True)

                for fpu_id in measure_fpuset:
                    actual_sn = rig.grid_state.FPU[fpu_id].serial_number
                    configured_sn = fpu_config[fpu_id]["serialnumber"]
                    if configured_sn != actual_sn:
                        raise ValueError(
                            "Actual serial number of FPU %i = %r does not match configuration (%r)"
                            % (fpu_id, actual_sn, configured_sn)
                        )

            #
            # Now execute all the required functional tests.
            #
            if opts.resetFPUs or (T.TASK_RESET_FPUS in tasks):
                logger.info("Resetting FPUs.... ")
                flush()
                rig.gd.resetFPUs(rig.grid_state, fpuset=measure_fpuset)
                logger.info("Resetting FPUs.... OK")

            if T.TASK_REWIND_FPUS in tasks:
                logger.info("[%s] ###" % T.TASK_REWIND_FPUS)

                logger.info("Rewinding FPUs near datum position...")

                rewind_fpus(rig, REWIND_POS_ALPHA, REWIND_POS_BETA)

            if T.TST_DATUM_ALPHA in tasks:
                logger.info("[%s] ###" % T.TST_DATUM_ALPHA)

                # We can use grid_state to display the starting position
                logger.info(
                    "The starting position (in degrees) is: %r"
                    % rig.gd.trackedAngles(rig.grid_state, retrieve=True)
                )
                test_datum(rig, dbe, DASEL_ALPHA)

            if T.TST_DATUM_BETA in tasks:
                logger.info("[%s] ###" % T.TST_DATUM_BETA)

                # We can use grid_state to display the starting position
                logger.info(
                    "The starting position (in degrees) is: %r"
                    % rig.gd.trackedAngles(rig.grid_state, retrieve=True)
                )
                test_datum(rig, dbe, DASEL_BETA)

            if T.TST_DATUM_BOTH in tasks:
                logger.info("[%s] ###" % T.TST_DATUM_BOTH)

                # We can use grid_state to display the starting position
                logger.info(
                    "The starting position (in degrees) is: %r"
                    % rig.gd.trackedAngles(rig.grid_state, retrieve=True)
                )
                test_datum(rig, dbe, DASEL_BOTH)

            if T.TASK_REFERENCE in tasks:
                logger.info("[%s] ###" % T.TASK_REFERENCE)
                # move all fpus to datum which are not there
                # (this is needed to operate the turntable)

                find_datum(rig.gd, rig.grid_state, opts=opts, uninitialized=True)

            if T.TASK_SELFTEST_NONFIBRE in tasks:
                logger.info("[%s] ###" % T.TASK_SELFTEST_NONFIBRE)
                selftest_nonfibre(
                    rig,
                    POS_REP_MEASUREMENT_PARS=POS_REP_MEASUREMENT_PARS,
                    MET_HEIGHT_MEASUREMENT_PARS=MET_HEIGHT_MEASUREMENT_PARS,
                    MET_HEIGHT_ANALYSIS_PARS=MET_HEIGHT_ANALYSIS_PARS,
                    POS_REP_ANALYSIS_PARS=POS_REP_ANALYSIS_PARS,
                )

            if T.TASK_SELFTEST_FIBRE in tasks:
                logger.info("[%s] ###" % T.TASK_SELFTEST_FIBRE)
                selftest_fibre(
                    rig,
                    MET_CAL_MEASUREMENT_PARS=MET_CAL_MEASUREMENT_PARS,
                    MET_CAL_TARGET_ANALYSIS_PARS=MET_CAL_TARGET_ANALYSIS_PARS,
                    MET_CAL_FIBRE_ANALYSIS_PARS=MET_CAL_FIBRE_ANALYSIS_PARS,
                    PUP_ALGN_MEASUREMENT_PARS=PUP_ALGN_MEASUREMENT_PARS,
                    PUP_ALGN_ANALYSIS_PARS=PUP_ALGN_ANALYSIS_PARS,
                )

            if T.TST_COLLDETECT in tasks:
                logger.info("[test_collision_detection] ###")
                test_limit(rig, dbe, "beta_collision", pars=COLLDECT_MEASUREMENT_PARS)

            if T.TST_ALPHA_MIN in tasks:
                logger.info("[test_limit_alpha_min] ###")
                test_limit(rig, dbe, "alpha_min", pars=COLLDECT_MEASUREMENT_PARS)

            if T.TST_ALPHA_MAX in tasks:
                logger.info("[test_limit_alpha_max] ###")
                test_limit(rig, dbe, "alpha_max", pars=COLLDECT_MEASUREMENT_PARS)

            if T.TST_BETA_MAX in tasks:
                logger.info("[test_limit_beta_max] ###")
                test_limit(rig, dbe, "beta_max", pars=COLLDECT_MEASUREMENT_PARS)

            if T.TST_BETA_MIN in tasks:
                logger.info("[test_limit_beta_min] ###")
                test_limit(rig, dbe, "beta_min", pars=COLLDECT_MEASUREMENT_PARS)

            if measure_fpuset and (
                tasks
                - set(
                    [
                        T.TASK_REPORT,
                        T.TASK_PLOT,
                        T.TASK_DUMP,
                        T.TST_BETA_MIN,
                        T.TST_BETA_MAX,
                        T.TST_ALPHA_MIN,
                        T.TST_ALPHA_MAX,
                        T.TASK_SELFTEST_FIBRE,
                        T.TASK_SELFTEST_NONFIBRE,
                        T.TASK_REFERENCE,
                        T.TST_DATUM_BETA,
                        T.TST_DATUM_ALPHA,
                        T.TASK_REWIND_FPUS,
                        T.TASK_INIT_GD,
                        T.TST_INITPOS,
                        T.TST_FLASH,
                        T.TST_CAN_CONNECTION,
                        T.TASK_INIT_RD,
                        T.TST_PUP_ALGN_CAM_CONNECTION,
                        T.TST_MET_HEIGHT_CAM_CONNECTION,
                        T.TST_MET_CAL_CAM_CONNECTION,
                        T.TST_POS_REP_CAM_CONNECTION,
                        T.TST_GATEWAY_CONNECTION,
                    ]
                )
            ):
                logger.info("*" * 60)
                logger.info("Functional tests passed, all OK!")
                print(
                    r"""

             _
           _| |                functional tests passed, all OK!
         _| | |                functional tests passed, all OK!
        | | | |                functional tests passed, all OK!
        | | | | __             functional tests passed, all OK!
        | | | |/  \            functional tests passed, all OK!
        |       /\ \           functional tests passed, all OK!
        |      /  \/           functional tests passed, all OK!
        |      \  /\           functional tests passed, all OK!
        |       \/ /           functional tests passed, all OK!
         \        /            functional tests passed, all OK!
          |     /              functional tests passed, all OK!
          |    |               functional tests passed, all OK!
                               functional tests passed, all OK!

    """
                )
                if opts.mail_on_error:
                    # add email logger for any critical errors
                    # (but not normal exit or manual termination)
                    add_email_handler(opts.mail_on_error)

            #
            # Move on to the verification measurement and evaluation tasks.
            #
            logger.info("----------------------------------------------------------------------")
            if T.TASK_INIT_GD2 in tasks:
                # this re-initializes the driver because
                # the range limits might have changed,
                # and they are only loaded by the
                # EtherCAN driver upon initialization
                logger.info("[initialize protected driver (re-loading limits)] ###")
                rig.init_driver(env=dbe.env, protected=True)

                for fpu_id in measure_fpuset:
                    actual_sn = rig.grid_state.FPU[fpu_id].serial_number
                    configured_sn = fpu_config[fpu_id]["serialnumber"]
                    if configured_sn != actual_sn:
                        raise ValueError(
                            "Actual serial number of FPU %i = %r does not match configuration (%r)"
                            % (fpu_id, actual_sn, configured_sn)
                        )

            if T.TASK_REFERENCE2 in tasks:
                logger.info("[%s] ###" % T.TASK_REFERENCE2)
                find_datum(rig.gd, rig.grid_state, opts=opts, uninitialized=True)

            if T.MEASURE_MET_CAL in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.MEASURE_MET_CAL)
                measure_metrology_calibration(rig, dbe, pars=MET_CAL_MEASUREMENT_PARS)
            if T.EVAL_MET_CAL in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.EVAL_MET_CAL)
                eval_metrology_calibration(
                    dbe, MET_CAL_TARGET_ANALYSIS_PARS, MET_CAL_FIBRE_ANALYSIS_PARS
                )

            if T.MEASURE_MET_HEIGHT in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.MEASURE_MET_HEIGHT)
                measure_metrology_height(rig, dbe, pars=MET_HEIGHT_MEASUREMENT_PARS)

            if T.EVAL_MET_HEIGHT in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.EVAL_MET_HEIGHT)
                eval_metrology_height(
                    dbe, MET_HEIGHT_ANALYSIS_PARS, MET_HEIGHT_EVALUATION_PARS
                )

            if T.MEASURE_DATUM_REP in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.MEASURE_DATUM_REP)
                measure_datum_repeatability(rig, dbe, pars=DATUM_REP_MEASUREMENT_PARS)

            if T.EVAL_DATUM_REP in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.EVAL_DATUM_REP)
                eval_datum_repeatability(dbe, DATUM_REP_ANALYSIS_PARS)

            if T.MEASURE_PUP_ALGN in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.MEASURE_PUP_ALGN)
                measure_pupil_alignment(rig, dbe, pars=PUP_ALGN_MEASUREMENT_PARS)
            if T.EVAL_PUP_ALGN in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.EVAL_PUP_ALGN)
                eval_pupil_alignment(
                    dbe,
                    PUP_ALGN_ANALYSIS_PARS=PUP_ALGN_ANALYSIS_PARS,
                    PUP_ALGN_EVALUATION_PARS=PUP_ALGN_EVALUATION_PARS,
                )

            if T.MEASURE_POS_REP in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.MEASURE_POS_REP)
                measure_positional_repeatability(
                    rig, dbe, pars=POS_REP_MEASUREMENT_PARS
                )

            if T.MEASURE_POS_REP_CHECK in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.MEASURE_POS_REP_CHECK)
                measure_positional_repeatability_check(
                    rig, dbe, pars=POS_REP_MEASUREMENT_PARS
                )

            if T.EVAL_POS_REP in tasks:
             	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.EVAL_POS_REP)
                eval_positional_repeatability(
                    dbe, POS_REP_ANALYSIS_PARS, POS_REP_EVALUATION_PARS
                )

            if T.EVAL_GEARBOX_CAL in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.EVAL_GEARBOX_CAL)
                eval_gearbox_calibration(
                    dbe, POS_REP_ANALYSIS_PARS, POS_REP_EVALUATION_PARS
                )

            if T.MEASURE_POS_VER in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.MEASURE_POS_VER)
                measure_positional_verification(rig, dbe, pars=POS_VER_MEASUREMENT_PARS)

            if T.TASK_PARK_FPUS in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.TASK_PARK_FPUS)
                # move all fpus back to datum
                find_datum(rig.gd, rig.grid_state, opts=opts, uninitialized=True)

            if T.TASK_HOME_TURNTABLE in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.TASK_HOME_TURNTABLE)
                safe_home_turntable(rig, rig.grid_state)

            if T.EVAL_POS_VER in tasks:
            	logger.info("----------------------------------------------------------------------")
                logger.info("[%s] ###" % T.EVAL_POS_VER)
                eval_positional_verification(
                    dbe, POS_REP_ANALYSIS_PARS, POS_VER_EVALUATION_PARS
                )

            #
            # Finally, check for plotting and reporting tasks.
            #
            if T.TASK_PLOT in tasks:
                logger.info("[%s] ###" % T.TASK_PLOT)
                plot(dbe, opts)

            if T.TASK_REPORT in tasks:
                logger.info("[%s] ###" % T.TASK_REPORT)
                report(dbe, opts)

            if T.TASK_DUMP in tasks:
                logger.info("[%s] ###" % T.TASK_DUMP)
                dump_data(dbe)

        except SystemExit:
            # Restore the turntable when an exit signal has been received.
            if T.TASK_HOME_TURNTABLE in tasks:
                logger.info("[%s] ###" % T.TASK_HOME_TURNTABLE)
                safe_home_turntable(rig, rig.grid_state)
                raise

    except Exception as exc:
        logger.exception("Exception triggered with message %r" % exc)
        logger.critical(
            """Fatal: exception hit with message:

 %s

Verification process aborted."""
            % exc
        )
        raise

    logger.info("Verification finished")
