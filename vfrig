#!/usr/bin/env python

from __future__ import absolute_import, division, print_function

import atexit
import os
import sys
from argparse import Namespace

from protectiondb import open_database_env
from vfr.verification_rig import Rig

from vfr.conf import (COLLDECT_MEASUREMENT_PARS,
                      DATUM_REP_ANALYSIS_PARS, DATUM_REP_MEASUREMENT_PARS,
                      IMAGE_ROOT_FOLDER, MET_CAL_CAMERA_IP_ADDRESS,
                      MET_CAL_FIBRE_ANALYSIS_PARS, MET_CAL_MEASUREMENT_PARS,
                      MET_CAL_TARGET_ANALYSIS_PARS, MET_HEIGHT_ANALYSIS_PARS,
                      MET_HEIGHT_CAMERA_IP_ADDRESS, MET_HEIGHT_EVALUATION_PARS,
                      MET_HEIGHT_MEASUREMENT_PARS, POS_REP_ANALYSIS_PARS,
                      POS_REP_CAMERA_IP_ADDRESS, POS_REP_EVALUATION_PARS,
                      POS_REP_MEASUREMENT_PARS, POS_VER_EVALUATION_PARS,
                      POS_VER_MEASUREMENT_PARS, PUP_ALGN_ANALYSIS_PARS,
                      PUP_ALGN_CAMERA_IP_ADDRESS, PUP_ALGN_EVALUATION_PARS,
                      PUP_ALGN_MEASUREMENT_PARS, REWIND_POS_ALPHA, REWIND_POS_BETA)

from vfr.connection import check_can_connection, check_connection
from vfr.db.snset import add_sns_to_set
from vfr.options import load_config, parse_args, check_sns_unique
from vfr.posdb import init_position
from vfr.TaskLogic import T, resolve
from vfr.task_config import MEASUREMENT_TASKS
from vfr.tests_common import find_datum, flush, cd_to_image_root
from vfr.verification_tasks.functional_tests import (DASEL_ALPHA, DASEL_BETA,
                                                     DASEL_BOTH, rewind_fpus, test_datum,
                                                     test_limit)
from vfr.verification_tasks.measure_datum_repeatability import (eval_datum_repeatability,
                                                                measure_datum_repeatability)
from vfr.verification_tasks.metrology_calibration import (eval_metrology_calibration,
                                                          measure_metrology_calibration)
from vfr.verification_tasks.metrology_height import (eval_metrology_height,
                                                     measure_metrology_height)
from vfr.verification_tasks.positional_repeatability import (eval_positional_repeatability,
                                                             measure_positional_repeatability)
from vfr.verification_tasks.positional_verification import (eval_positional_verification,
                                                             measure_positional_verification)
from vfr.verification_tasks.pupil_alignment import (eval_pupil_alignment,
                                                    measure_pupil_alignment)
from vfr.verification_tasks.report import dump_data, report
from vfr.verification_tasks.rig_selftest import (selftest_fibre,
                                                 selftest_nonfibre)

if __name__ == "__main__":
    opts = parse_args()
    print ("starting verification")
    print ("tasks = %r" % opts.tasks)

    env = open_database_env(mockup=opts.mockup)

    if env is None:
        raise ValueError(
            "The environment variable FPU_DATABASE needs to"
            " be set to the directory path of the LMDB position database!"
        )

    vfdb = env.open_db("verification")

    fpu_config, measure_fpuset, eval_fpuset = load_config(env, vfdb, opts.setup_file, opts=opts)


    # change current directory to image root folder, so that
    # we can use relative image paths in both measurement
    # and evaluation tasks
    cd_to_image_root(IMAGE_ROOT_FOLDER)
    # check connections to cameras and EtherCAN gateway


    rig_opts = Namespace(**{ k : vars(opts)[k] for k in [
        'gateway_address',
        'gateway_port',
        'verbosity',
        'mockup',
        'manual_lamp_control',
        'always_reset_fpus',
        're_initialize',
        'repeat_passed_tests',
        'repeat_limit_tests',
        'skip_fibre',
        'N',
        'bus_repeat_dummy_delay',
        'ignore_analysis_failures',
    ]})

    db_opts = Namespace(**{ k : vars(opts)[k] for k in [
        'report_format',
        'verbosity',
        're_initialize',
        'output_file',
        'reuse_serialnum',
        'update_protection_limits',
        'protection_tolerance',
        'display_alpha_max',
        'display_alpha_min',
        'display_beta_max',
        'display_beta_min',
        'record_count',
    ]})

    # we define two structs which group hardware
    # access and database access.
    rig_params = Namespace(
        measure_fpuset=measure_fpuset,
        opts=rig_opts,
    )

    fpudb = env.open_db("fpu")

    dbe = Namespace(
        env=env,
        fpudb=fpudb,
        vfdb=vfdb,
        eval_fpuset=eval_fpuset,
        fpu_config=fpu_config,
        opts=db_opts,
    )

    # resolve high-level tasks and dependent checks and measurements into
    # low-level actions
    tasks = resolve(opts.tasks, rig_params, dbe)


    if not rig_params.measure_fpuset: # pylint: disable=no-member
        # no measurements, we remove all related tasks
        print("No FPUs in measurement set, removing all measurement tasks")
        tasks -= MEASUREMENT_TASKS

    if (tasks &  MEASUREMENT_TASKS):
        rig = Rig(rig_params, fpu_config=fpu_config)

    if opts.expand_tasks:
        print("Expanded tasks: %s" % list(tasks))
        sys.exit(0)

    if T.TST_GATEWAY_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_GATEWAY_CONNECTION)
        check_connection(opts, "gateway", opts.gateway_address)

    if T.TST_POS_REP_CAM_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_POS_REP_CAM_CONNECTION)
        if opts.mockup:
            print ("skipping test...")
        else:
            check_connection(
                opts, "positional repeatability camera", POS_REP_CAMERA_IP_ADDRESS
            )

    if T.TST_MET_CAL_CAM_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_MET_CAL_CAM_CONNECTION)
        if opts.mockup:
            print ("skipping test...")
        else:
            check_connection(
                opts, "metrology calibration camera", MET_CAL_CAMERA_IP_ADDRESS
            )

    if T.TST_MET_HEIGHT_CAM_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_MET_HEIGHT_CAM_CONNECTION)
        if opts.mockup:
            print ("skipping test...")
        else:
            check_connection(
                opts, "metrology height camera", MET_HEIGHT_CAMERA_IP_ADDRESS
            )

    if T.TST_PUP_ALGN_CAM_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_PUP_ALGN_CAM_CONNECTION)
        if opts.mockup:
            print ("skipping test...")
        else:
            check_connection(
                opts, "pupil alignment camera", PUP_ALGN_CAMERA_IP_ADDRESS
            )

    if T.TASK_INIT_RD in tasks:

        print ("[initialize unprotected FPU driver] ###")
        rig.init_driver(protected=False)

    if T.TST_CAN_CONNECTION in tasks:
        print ("[test_can_connection] ###")
        for fpu_id in range(opts.N):
            rv = check_can_connection(rig.rd, rig.grid_state, rig.opts, fpu_id)

    if T.TST_FLASH in tasks:
        print ("[flash_snum] ###")
        check_sns_unique(rig, dbe)
        flashed_numbers = []
        for fpu_id in measure_fpuset:
            serial_number = fpu_config[fpu_id]["serialnumber"]

            print (
                "flashing FPU #%i with serial number %r ... " % (fpu_id, serial_number),
                end='',
            )
            flush()
            rval = rig.rd.writeSerialNumber(fpu_id, serial_number, grid_state)
            flashed_numbers.append(serial_number)
            print (rval)
            rig.rd.readSerialNumbers(grid_state)
        # we update the set of FPUs which are in the database,
        # so that we can iterate over existing data when generating reports.
        add_sns_to_set(dbe, flashed_numbers)




    if T.TST_INITPOS in tasks:
        print ("[init_positions] ###")

        for fpu_id in measure_fpuset:
            alpha_start, beta_start = fpu_config[fpu_id]["pos"]
            serialnumber = fpu_config[fpu_id]["serialnumber"]

            init_position(
                dbe,
                fpu_id,
                serialnumber,
                alpha_start,
                beta_start,
            )

    # switch to protected driver instance, if needed

    if T.TASK_INIT_GD in tasks:

        print ("[initialize protected driver] ###")
        rig.init_driver(env=env, protected=True)

        for fpu_id in measure_fpuset:
            actual_sn = rig.grid_state.FPU[fpu_id].serial_number
            configured_sn = fpu_config[fpu_id]["serialnumber"]
            if configured_sn != actual_sn:
                raise ValueError(
                    "actual serial number of FPU %i = %r does not match configuration (%r)"
                    % (fpu_id, actual_sn, configured_sn)
                )

    if opts.resetFPUs:
        print ("resetting FPUs.... ", end='')
        flush()
        rig.gd.resetFPUs(rig.grid_state, fpuset=measure_fpuset)
        print ("OK")

    if T.TASK_REWIND_FPUS in tasks:
        print ("[%s] ###" % T.TASK_REWIND_FPUS)

        print ("rewinding FPUs near datum position..." )

        rewind_fpus(rig, REWIND_POS_ALPHA, REWIND_POS_BETA)

    if T.TST_DATUM_ALPHA in tasks:
        print ("[%s] ###" % T.TST_DATUM_ALPHA)

        # We can use grid_state to display the starting position
        print (
            "the starting position (in degrees) is:",
            rig.gd.trackedAngles(rig.grid_state, retrieve=True),
        )
        test_datum(
            rig, dbe, DASEL_ALPHA
        )

    if T.TST_DATUM_BETA in tasks:
        print ("[%s] ###" % T.TST_DATUM_BETA)

        # We can use grid_state to display the starting position
        print (
            "the starting position (in degrees) is:",
            rig.gd.trackedAngles(rig.grid_state, retrieve=True),
        )
        test_datum(
            rig, dbe, DASEL_BETA
        )

    if T.TST_DATUM_BOTH in tasks:
        print ("[%s] ###" % T.TST_DATUM_BOTH)

        # We can use grid_state to display the starting position
        print (
            "the starting position (in degrees) is:",
            rig.gd.trackedAngles(rig.grid_state, retrieve=True),
        )
        test_datum(
            rig, dbe, DASEL_BOTH
        )

    if T.TASK_REFERENCE in tasks:
        print ("[%s] ###" % T.TASK_REFERENCE)
        # move all fpus to datum which are not there
        # (this is needed to operate the turntable)

        find_datum(rig.gd, rig.grid_state, opts=opts, uninitialized=True)

    if T.TASK_SELFTEST_NONFIBRE in tasks:
        print ("[%s] ###" % T.TASK_SELFTEST_NONFIBRE)
        selftest_nonfibre(rig,
            POS_REP_MEASUREMENT_PARS=POS_REP_MEASUREMENT_PARS,
            MET_HEIGHT_MEASUREMENT_PARS=MET_HEIGHT_MEASUREMENT_PARS,
            MET_HEIGHT_ANALYSIS_PARS=MET_HEIGHT_ANALYSIS_PARS,
            POS_REP_ANALYSIS_PARS=POS_REP_ANALYSIS_PARS,
        )

    if T.TASK_SELFTEST_FIBRE in tasks:
        print ("[%s] ###" % T.TASK_SELFTEST_FIBRE)
        selftest_fibre(
            rig,
            MET_CAL_MEASUREMENT_PARS=MET_CAL_MEASUREMENT_PARS,
            MET_CAL_TARGET_ANALYSIS_PARS=MET_CAL_TARGET_ANALYSIS_PARS,
            MET_CAL_FIBRE_ANALYSIS_PARS=MET_CAL_FIBRE_ANALYSIS_PARS,
            PUP_ALGN_MEASUREMENT_PARS=PUP_ALGN_MEASUREMENT_PARS,
            PUP_ALGN_ANALYSIS_PARS=PUP_ALGN_ANALYSIS_PARS,
        )

    if T.TST_COLLDETECT in tasks:
        print ("[test_collision_detection] ###")
        test_limit(
            rig, dbe,
            "beta_collision",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.TST_ALPHA_MIN in tasks:
        print ("[test_limit_alpha_min] ###")
        test_limit(
            rig, dbe,
            "alpha_min",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.TST_ALPHA_MAX in tasks:
        print ("[test_limit_alpha_max] ###")
        test_limit(
            rig, dbe,
            "alpha_max",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.TST_BETA_MAX in tasks:
        print ("[test_limit_beta_max] ###")
        test_limit(
            rig, dbe,
            "beta_max",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.TST_BETA_MIN in tasks:
        print ("[test_limit_beta_min] ###")
        test_limit(
            rig, dbe,
            "beta_min",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.MEASURE_MET_CAL in tasks:
        print ("[%s] ###" % T.MEASURE_MET_CAL)
        measure_metrology_calibration(
            rig, dbe,
            pars=MET_CAL_MEASUREMENT_PARS
        )
    if T.EVAL_MET_CAL in tasks:
        print ("[%s] ###" % T.EVAL_MET_CAL)
        eval_metrology_calibration(
            dbe,
            MET_CAL_TARGET_ANALYSIS_PARS,
            MET_CAL_FIBRE_ANALYSIS_PARS,
        )

    if T.MEASURE_MET_HEIGHT in tasks:
        print ("[%s] ###" % T.MEASURE_MET_HEIGHT)
        measure_metrology_height(
            rig, dbe,
            pars=MET_HEIGHT_MEASUREMENT_PARS
        )

    if T.EVAL_MET_HEIGHT in tasks:
        print ("[%s] ###" % T.EVAL_MET_HEIGHT)
        eval_metrology_height(
            dbe,
            MET_HEIGHT_ANALYSIS_PARS,
            MET_HEIGHT_EVALUATION_PARS,
        )

    if T.MEASURE_DATUM_REP in tasks:
        print ("[%s] ###" % T.MEASURE_DATUM_REP)
        measure_datum_repeatability(
            rig, dbe,
            pars=DATUM_REP_MEASUREMENT_PARS
        )

    if T.EVAL_DATUM_REP in tasks:
        print ("[%s] ###" % T.EVAL_DATUM_REP)
        eval_datum_repeatability(
            dbe,
            DATUM_REP_ANALYSIS_PARS,
        )

    if T.MEASURE_PUP_ALGN in tasks:
        print ("[%s] ###" % T.MEASURE_PUP_ALGN)
        measure_pupil_alignment(
            rig, dbe,
            pars=PUP_ALGN_MEASUREMENT_PARS
        )
    if T.EVAL_PUP_ALGN in tasks:
        print ("[%s] ###" % T.EVAL_PUP_ALGN)
        eval_pupil_alignment(
            dbe,
            PUP_ALGN_ANALYSIS_PARS=PUP_ALGN_ANALYSIS_PARS,
            PUP_ALGN_EVALUATION_PARS=PUP_ALGN_EVALUATION_PARS
        )

    if T.MEASURE_POS_REP in tasks:
        print ("[%s] ###" % T.MEASURE_POS_REP)
        measure_positional_repeatability(
            rig, dbe,
            pars=POS_REP_MEASUREMENT_PARS
        )

    if T.EVAL_POS_REP in tasks:
        print ("[%s] ###" % T.EVAL_POS_REP)
        eval_positional_repeatability(
            dbe,
            POS_REP_ANALYSIS_PARS,
            POS_REP_EVALUATION_PARS,
        )

    if T.MEASURE_POS_VER in tasks:
        print ("[%s] ###" % T.MEASURE_POS_VER)
        measure_positional_verification(
            rig, dbe,
            pars=POS_VER_MEASUREMENT_PARS
        )

    if T.TASK_PARK_FPUS in tasks:
        print ("[%s] ###" % T.TASK_PARK_FPUS)
        # move all fpus back to datum
        find_datum(rig.gd, rig.grid_state, opts=opts, uninitialized=True)

    if T.EVAL_POS_VER in tasks:
        print ("[%s] ###" % T.EVAL_POS_VER)
        eval_positional_verification(
            dbe,
            POS_REP_ANALYSIS_PARS,
            POS_VER_EVALUATION_PARS,
        )

    if T.TASK_REPORT in tasks:
        print ("[%s] ###" % T.TASK_REPORT)
        report(dbe, opts)

    if T.TASK_DUMP in tasks:
        print ("[%s] ###" % T.TASK_DUMP)
        dump_data(dbe)
