#!/usr/bin/env python

from __future__ import absolute_import, division, print_function

import atexit
from argparse import Namespace

from protectiondb import open_database_env
from vfr import hw
from vfr import hwsimulation
from vfr.conf import (COLLDECT_MEASUREMENT_PARS,
                      DATUM_REP_ANALYSIS_PARS, DATUM_REP_MEASUREMENT_PARS,
                      IMAGE_ROOT_FOLDER, MET_CAL_CAMERA_IP_ADDRESS,
                      MET_CAL_FIBRE_ANALYSIS_PARS, MET_CAL_MEASUREMENT_PARS,
                      MET_CAL_TARGET_ANALYSIS_PARS, MET_HEIGHT_ANALYSIS_PARS,
                      MET_HEIGHT_CAMERA_IP_ADDRESS, MET_HEIGHT_EVALUATION_PARS,
                      MET_HEIGHT_MEASUREMENT_PARS, POS_REP_ANALYSIS_PARS,
                      POS_REP_CAMERA_IP_ADDRESS, POS_REP_EVALUATION_PARS,
                      POS_REP_MEASUREMENT_PARS, POS_VER_EVALUATION_PARS,
                      POS_VER_MEASUREMENT_PARS, PUP_ALGN_ANALYSIS_PARS,
                      PUP_ALGN_CAMERA_IP_ADDRESS, PUP_ALGN_EVALUATION_PARS,
                      PUP_ALGN_MEASUREMENT_PARS)
from vfr.connection import (check_can_connection, check_connection,
                            init_driver)
from vfr.db.snset import add_sns_to_set
from vfr.options import load_config, parse_args, check_sns_unique
from vfr.posdb import init_position
from vfr.TaskLogic import T, resolve
from vfr.tests_common import find_datum, flush, cd_to_image_root
from vfr.verification_tasks.functional_tests import (DASEL_ALPHA, DASEL_BETA,
                                                     DASEL_BOTH, test_datum,
                                                     test_limit)
from vfr.verification_tasks.measure_datum_repeatability import (eval_datum_repeatability,
                                                                measure_datum_repeatability)
from vfr.verification_tasks.metrology_calibration import (eval_metrology_calibration,
                                                          measure_metrology_calibration)
from vfr.verification_tasks.metrology_height import (eval_metrology_height,
                                                     measure_metrology_height)
from vfr.verification_tasks.positional_repeatability import (eval_positional_repeatability,
                                                             measure_positional_repeatability)
from vfr.verification_tasks.positional_verification import (eval_positional_verification,
                                                             measure_positional_verification)
from vfr.verification_tasks.pupil_alignment import (eval_pupil_alignment,
                                                    measure_pupil_alignment)
from vfr.verification_tasks.report import dump_data, report
from vfr.verification_tasks.rig_selftest import (selftest_fibre,
                                                 selftest_nonfibre)

if __name__ == "__main__":
    opts = parse_args()
    print ("starting verification")
    print ("tasks = %r" % opts.tasks)

    env = open_database_env(mockup=opts.mockup)

    if env is None:
        raise ValueError(
            "The environment variable FPU_DATABASE needs to"
            " be set to the directory path of the LMDB position database!"
        )

    vfdb = env.open_db("verification")

    fpu_config, measure_fpuset, eval_fpuset = load_config(env, vfdb, opts.setup_file, opts=opts)


    # change current directory to image root folder, so that
    # we can use relative image paths in both measurement
    # and evaluation tasks
    cd_to_image_root(IMAGE_ROOT_FOLDER)
    # check connections to cameras and EtherCAN gateway

    if opts.mockup:
        lctrl = hwsimulation.lampController()
    else:
        lctrl = hw.lampController()

    # make sure that lamps are switched off on program exit
    def lamps_off():
        lctrl.switch_fibre_backlight("off")
        lctrl.switch_ambientlight("off")
        lctrl.switch_silhouettelight("off")

    if not opts.mockup:
        atexit.register(lamps_off)

    context = Namespace(            env=env,
                                    fpudb=None,
                                    vfdb=vfdb,
                                    gd=None,
                                    lctrl=lctrl,
                                    grid_state=None,
                                    measure_fpuset=measure_fpuset,
                                    eval_fpuset=eval_fpuset,
                                    fpu_config=fpu_config,
                                    opts=opts,
    )

    # resolve high-level tasks and dependent checks and measurements into
    # low-level actions
    tasks = resolve(opts.tasks, context)

    if not context.measure_fpuset:
        # no measurements, we remove all related tasks
        print("No FPUs in measurement set, removing all measurement tasks")
        tasks -= set([
            T.TST_GATEWAY_CONNECTION,
            T.TST_POS_REP_CAM_CONNECTION,
            T.TST_POS_REP_CAM_CONNECTION,
            T.TST_MET_CAL_CAM_CONNECTION,
            T.TST_MET_HEIGHT_CAM_CONNECTION,
            T.TST_PUP_ALGN_CAM_CONNECTION,
            T.TASK_INIT_RD,
            T.TST_CAN_CONNECTION,
            T.TST_FLASH,
            T.TST_INITPOS,
            T.TASK_INIT_GD,
            T.TST_DATUM_ALPHA,
            T.TST_DATUM_BETA,
            T.TST_DATUM_BOTH,
            T.TASK_REFERENCE,
            T.TASK_SELFTEST_NONFIBRE,
            T.TASK_SELFTEST_FIBRE,
            T.TST_COLLDETECT,
            T.TST_ALPHA_MIN,
            T.TST_ALPHA_MAX,
            T.TST_BETA_MAX,
            T.TST_BETA_MIN,
            T.MEASURE_MET_CAL,
            T.MEASURE_MET_HEIGHT,
            T.MEASURE_DATUM_REP,
            T.MEASURE_PUP_ALGN,
            T.MEASURE_POS_REP,
            T.MEASURE_POS_VER,
            T.TASK_PARK_FPUS,
        ])

    if T.TST_GATEWAY_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_GATEWAY_CONNECTION)
        check_connection(opts, "gateway", opts.gateway_address)

    if T.TST_POS_REP_CAM_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_POS_REP_CAM_CONNECTION)
        if opts.mockup:
            print ("skipping test...")
        else:
            check_connection(
                opts, "positional repeatability camera", POS_REP_CAMERA_IP_ADDRESS
            )

    if T.TST_MET_CAL_CAM_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_MET_CAL_CAM_CONNECTION)
        if opts.mockup:
            print ("skipping test...")
        else:
            check_connection(
                opts, "metrology calibration camera", MET_CAL_CAMERA_IP_ADDRESS
            )

    if T.TST_MET_HEIGHT_CAM_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_MET_HEIGHT_CAM_CONNECTION)
        if opts.mockup:
            print ("skipping test...")
        else:
            check_connection(
                opts, "metrology height camera", MET_HEIGHT_CAMERA_IP_ADDRESS
            )

    if T.TST_PUP_ALGN_CAM_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_PUP_ALGN_CAM_CONNECTION)
        if opts.mockup:
            print ("skipping test...")
        else:
            check_connection(
                opts, "pupil alignment camera", PUP_ALGN_CAMERA_IP_ADDRESS
            )

    if T.TASK_INIT_RD in tasks:

        print ("[initialize unprotected FPU driver] ###")

        rd, grid_state = init_driver(opts, max(measure_fpuset), protected=False)

        context.grid_state = grid_state

    if T.TST_CAN_CONNECTION in tasks:
        print ("[test_can_connection] ###")
        for fpu_id in measure_fpuset:
            rv = check_can_connection(rd, grid_state, opts, fpu_id)

    if T.TST_FLASH in tasks:
        print ("[flash_snum] ###")
        check_sns_unique(context)
        flashed_numbers = []
        for fpu_id in measure_fpuset:
            serial_number = fpu_config[fpu_id]["serialnumber"]

            print (
                "flashing FPU #%i with serial number %r ... " % (fpu_id, serial_number),
                end='',
            )
            flush()
            rval = rd.writeSerialNumber(fpu_id, serial_number, grid_state)
            flashed_numbers.append(serial_number)
            print (rval)
            rd.readSerialNumbers(grid_state)
        # we update the set of FPUs which are in the database,
        # so that we can iterate over existing data when generating reports.
        add_sns_to_set(context, flashed_numbers)



    context.fpudb = env.open_db("fpu")

    if T.TST_INITPOS in tasks:
        print ("[init_positions] ###")

        for fpu_id in measure_fpuset:
            alpha_start, beta_start = fpu_config[fpu_id]["pos"]
            serialnumber = fpu_config[fpu_id]["serialnumber"]

            init_position(
                context,
                fpu_id,
                serialnumber,
                alpha_start,
                beta_start,
            )

    # switch to protected driver instance, if needed

    if T.TASK_INIT_GD in tasks:

        if locals().has_key("rd"):
            del rd  # delete raw (unprotected) driver instance

        print ("[initialize protected driver] ###")
        gd, grid_state = init_driver(opts, max(measure_fpuset), env=env, protected=True)
        gd.readSerialNumbers(grid_state)

        context.gd = gd
        context.grid_state = grid_state

        for fpu_id in measure_fpuset:
            actual_sn = grid_state.FPU[fpu_id].serial_number
            configured_sn = fpu_config[fpu_id]["serialnumber"]
            if configured_sn != actual_sn:
                raise ValueError(
                    "actual serial number of FPU %i = %r does not match configuration (%r)"
                    % (fpu_id, actual_sn, configured_sn)
                )

    if opts.resetFPUs:
        print ("resetting FPUs.... ", end='')
        flush()
        gd.resetFPUs(grid_state, fpuset=measure_fpuset)
        print ("OK")

    if T.TST_DATUM_ALPHA in tasks:
        print ("[%s] ###" % T.TST_DATUM_ALPHA)

        # We can use grid_state to display the starting position
        print (
            "the starting position (in degrees) is:",
            gd.trackedAngles(grid_state, retrieve=True),
        )
        test_datum(
            context, DASEL_ALPHA
        )

    if T.TST_DATUM_BETA in tasks:
        print ("[%s] ###" % T.TST_DATUM_BETA)

        # We can use grid_state to display the starting position
        print (
            "the starting position (in degrees) is:",
            gd.trackedAngles(grid_state, retrieve=True),
        )
        test_datum(
            context, DASEL_BETA
        )

    if T.TST_DATUM_BOTH in tasks:
        print ("[%s] ###" % T.TST_DATUM_BOTH)

        # We can use grid_state to display the starting position
        print (
            "the starting position (in degrees) is:",
            gd.trackedAngles(grid_state, retrieve=True),
        )
        test_datum(
            context, DASEL_BOTH
        )

    if T.TASK_REFERENCE in tasks:
        print ("[%s] ###" % T.TASK_REFERENCE)
        # move all fpus to datum which are not there
        # (this is needed to operate the turntable)

        find_datum(gd, grid_state, opts=opts, uninitialized=True)

    if T.TASK_SELFTEST_NONFIBRE in tasks:
        print ("[%s] ###" % T.TASK_SELFTEST_NONFIBRE)
        selftest_nonfibre(context,
            POS_REP_MEASUREMENT_PARS=POS_REP_MEASUREMENT_PARS,
            MET_HEIGHT_MEASUREMENT_PARS=MET_HEIGHT_MEASUREMENT_PARS,
            MET_HEIGHT_ANALYSIS_PARS=MET_HEIGHT_ANALYSIS_PARS,
            POS_REP_ANALYSIS_PARS=POS_REP_ANALYSIS_PARS,
        )

    if T.TASK_SELFTEST_FIBRE in tasks:
        print ("[%s] ###" % T.TASK_SELFTEST_FIBRE)
        selftest_fibre(
            context,
            MET_CAL_MEASUREMENT_PARS=MET_CAL_MEASUREMENT_PARS,
            MET_CAL_TARGET_ANALYSIS_PARS=MET_CAL_TARGET_ANALYSIS_PARS,
            MET_CAL_FIBRE_ANALYSIS_PARS=MET_CAL_FIBRE_ANALYSIS_PARS,
            PUP_ALGN_MEASUREMENT_PARS=PUP_ALGN_MEASUREMENT_PARS,
            PUP_ALGN_ANALYSIS_PARS=PUP_ALGN_ANALYSIS_PARS,
        )

    if T.TST_COLLDETECT in tasks:
        print ("[test_collision_detection] ###")
        test_limit(
            context,
            "beta_collision",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.TST_ALPHA_MIN in tasks:
        print ("[test_limit_alpha_min] ###")
        test_limit(
            context,
            "alpha_min",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.TST_ALPHA_MAX in tasks:
        print ("[test_limit_alpha_max] ###")
        test_limit(
            context,
            "alpha_max",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.TST_BETA_MAX in tasks:
        print ("[test_limit_beta_max] ###")
        test_limit(
            context,
            "beta_max",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.TST_BETA_MIN in tasks:
        print ("[test_limit_beta_min] ###")
        test_limit(
            context,
            "beta_min",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.MEASURE_MET_CAL in tasks:
        print ("[%s] ###" % T.MEASURE_MET_CAL)
        measure_metrology_calibration(
            context,
            pars=MET_CAL_MEASUREMENT_PARS
        )
    if T.EVAL_MET_CAL in tasks:
        print ("[%s] ###" % T.EVAL_MET_CAL)
        eval_metrology_calibration(
            context,
            MET_CAL_TARGET_ANALYSIS_PARS,
            MET_CAL_FIBRE_ANALYSIS_PARS,
        )

    if T.MEASURE_MET_HEIGHT in tasks:
        print ("[%s] ###" % T.MEASURE_MET_HEIGHT)
        measure_metrology_height(
            context,
            pars=MET_HEIGHT_MEASUREMENT_PARS
        )

    if T.EVAL_MET_HEIGHT in tasks:
        print ("[%s] ###" % T.EVAL_MET_HEIGHT)
        eval_metrology_height(
            context,
            MET_HEIGHT_ANALYSIS_PARS,
            MET_HEIGHT_EVALUATION_PARS,
        )

    if T.MEASURE_DATUM_REP in tasks:
        print ("[%s] ###" % T.MEASURE_DATUM_REP)
        measure_datum_repeatability(
            context,
            pars=DATUM_REP_MEASUREMENT_PARS
        )

    if T.EVAL_DATUM_REP in tasks:
        print ("[%s] ###" % T.EVAL_DATUM_REP)
        eval_datum_repeatability(
            context,
            DATUM_REP_ANALYSIS_PARS,
        )

    if T.MEASURE_PUP_ALGN in tasks:
        print ("[%s] ###" % T.MEASURE_PUP_ALGN)
        measure_pupil_alignment(
            context,
            pars=PUP_ALGN_MEASUREMENT_PARS
        )
    if T.EVAL_PUP_ALGN in tasks:
        print ("[%s] ###" % T.EVAL_PUP_ALGN)
        eval_pupil_alignment(
            context,
            PUP_ALGN_ANALYSIS_PARS=PUP_ALGN_ANALYSIS_PARS,
            PUP_ALGN_EVALUATION_PARS=PUP_ALGN_EVALUATION_PARS
        )

    if T.MEASURE_POS_REP in tasks:
        print ("[%s] ###" % T.MEASURE_POS_REP)
        measure_positional_repeatability(
            context,
            pars=POS_REP_MEASUREMENT_PARS
        )

    if T.EVAL_POS_REP in tasks:
        print ("[%s] ###" % T.EVAL_POS_REP)
        eval_positional_repeatability(
            context,
            POS_REP_ANALYSIS_PARS,
            POS_REP_EVALUATION_PARS,
        )

    if T.MEASURE_POS_VER in tasks:
        print ("[%s] ###" % T.MEASURE_POS_VER)
        measure_positional_verification(
            context,
            pars=POS_VER_MEASUREMENT_PARS
        )

    if T.TASK_PARK_FPUS in tasks:
        print ("[%s] ###" % T.TASK_PARK_FPUS)
        # move all fpus back to datum
        find_datum(gd, grid_state, opts=opts, uninitialized=True)

    if T.EVAL_POS_VER in tasks:
        print ("[%s] ###" % T.EVAL_POS_VER)
        eval_positional_verification(
            context,
            POS_REP_ANALYSIS_PARS,
            POS_VER_EVALUATION_PARS,
        )

    if T.TASK_REPORT in tasks:
        print ("[%s] ###" % T.TASK_REPORT)
        report(context)

    if T.TASK_DUMP in tasks:
        print ("[%s] ###" % T.TASK_DUMP)
        dump_data(context)
