#!/usr/bin/env python

from __future__ import absolute_import, division, print_function

import atexit
import sys
from argparse import Namespace

from protectiondb import open_database_env
from vfr import hw as real_hw
from vfr import hwsimulation
from vfr.conf import (COLLDECT_MEASUREMENT_PARS,
                      DATUM_REP_ANALYSIS_PARS, DATUM_REP_MEASUREMENT_PARS,
                      IMAGE_ROOT_FOLDER, MET_CAL_CAMERA_IP_ADDRESS,
                      MET_CAL_FIBRE_ANALYSIS_PARS, MET_CAL_MEASUREMENT_PARS,
                      MET_CAL_TARGET_ANALYSIS_PARS, MET_HEIGHT_ANALYSIS_PARS,
                      MET_HEIGHT_CAMERA_IP_ADDRESS, MET_HEIGHT_EVALUATION_PARS,
                      MET_HEIGHT_MEASUREMENT_PARS, POS_REP_ANALYSIS_PARS,
                      POS_REP_CAMERA_IP_ADDRESS, POS_REP_EVALUATION_PARS,
                      POS_REP_MEASUREMENT_PARS, POS_VER_EVALUATION_PARS,
                      POS_VER_MEASUREMENT_PARS, PUP_ALGN_ANALYSIS_PARS,
                      PUP_ALGN_CAMERA_IP_ADDRESS, PUP_ALGN_EVALUATION_PARS,
                      PUP_ALGN_MEASUREMENT_PARS, REWIND_POS_ALPHA, REWIND_POS_BETA)

from vfr.connection import (check_can_connection, check_connection,
                            init_driver)
from vfr.db.snset import add_sns_to_set
from vfr.options import load_config, parse_args, check_sns_unique
from vfr.posdb import init_position
from vfr.TaskLogic import T, resolve
from vfr.tests_common import find_datum, flush, cd_to_image_root
from vfr.verification_tasks.functional_tests import (DASEL_ALPHA, DASEL_BETA,
                                                     DASEL_BOTH, rewind_fpus, test_datum,
                                                     test_limit)
from vfr.verification_tasks.measure_datum_repeatability import (eval_datum_repeatability,
                                                                measure_datum_repeatability)
from vfr.verification_tasks.metrology_calibration import (eval_metrology_calibration,
                                                          measure_metrology_calibration)
from vfr.verification_tasks.metrology_height import (eval_metrology_height,
                                                     measure_metrology_height)
from vfr.verification_tasks.positional_repeatability import (eval_positional_repeatability,
                                                             measure_positional_repeatability)
from vfr.verification_tasks.positional_verification import (eval_positional_verification,
                                                             measure_positional_verification)
from vfr.verification_tasks.pupil_alignment import (eval_pupil_alignment,
                                                    measure_pupil_alignment)
from vfr.verification_tasks.report import dump_data, report
from vfr.verification_tasks.rig_selftest import (selftest_fibre,
                                                 selftest_nonfibre)

if __name__ == "__main__":
    opts = parse_args()
    print ("starting verification")
    print ("tasks = %r" % opts.tasks)

    env = open_database_env(mockup=opts.mockup)

    if env is None:
        raise ValueError(
            "The environment variable FPU_DATABASE needs to"
            " be set to the directory path of the LMDB position database!"
        )

    vfdb = env.open_db("verification")

    fpu_config, measure_fpuset, eval_fpuset = load_config(env, vfdb, opts.setup_file, opts=opts)


    # change current directory to image root folder, so that
    # we can use relative image paths in both measurement
    # and evaluation tasks
    cd_to_image_root(IMAGE_ROOT_FOLDER)
    # check connections to cameras and EtherCAN gateway


    if opts.mockup:
        hw = hwsimulation
    else:
        hw = real_hw

    rig_opts = Namespace(**{ k : vars(opts)[k] for k in [
        'verbosity',
        'mockup',
        'manual_lamp_control',
        'always_reset_fpus',
        're_initialize',
        'repeat_passed_tests',
        'repeat_limit_tests',
        'skip_fibre',
        'N',
        'bus_repeat_dummy_delay',
        'ignore_analysis_failures',
    ]})

    db_opts = Namespace(**{ k : vars(opts)[k] for k in [
        'report_format',
        'verbosity',
        're_initialize',
        'output_file',
        'reuse_serialnum',
        'update_protection_limits',
        'protection_tolerance',
        'display_alpha_max',
        'display_alpha_min',
        'display_beta_max',
        'display_beta_min',
        'record_count',
    ]})

    # we define two structs which group hardware
    # access and database access.
    rig = Namespace(
        hw=hw,
        gd=None,
        lctrl=None,
        grid_state=None,
        measure_fpuset=measure_fpuset,
        fpu_config=fpu_config,
        opts=rig_opts,
    )

    fpudb = env.open_db("fpu")

    dbe = Namespace(
        env=env,
        fpudb=fpudb,
        vfdb=vfdb,
        eval_fpuset=eval_fpuset,
        fpu_config=fpu_config,
        opts=db_opts,
    )

    # resolve high-level tasks and dependent checks and measurements into
    # low-level actions
    tasks = resolve(opts.tasks, rig, dbe)

    measurement_tasks = set([
        T.TST_GATEWAY_CONNECTION,
        T.TST_POS_REP_CAM_CONNECTION,
        T.TST_POS_REP_CAM_CONNECTION,
        T.TST_MET_CAL_CAM_CONNECTION,
        T.TST_MET_HEIGHT_CAM_CONNECTION,
        T.TST_PUP_ALGN_CAM_CONNECTION,
        T.TASK_INIT_RD,
        T.TST_CAN_CONNECTION,
        T.TST_FLASH,
        T.TST_INITPOS,
        T.TASK_INIT_GD,
        T.TST_DATUM_ALPHA,
        T.TST_DATUM_BETA,
        T.TST_DATUM_BOTH,
        T.TASK_REFERENCE,
        T.TASK_SELFTEST_NONFIBRE,
        T.TASK_SELFTEST_FIBRE,
        T.TST_COLLDETECT,
        T.TST_ALPHA_MIN,
        T.TST_ALPHA_MAX,
        T.TST_BETA_MAX,
        T.TST_BETA_MIN,
        T.MEASURE_MET_CAL,
        T.MEASURE_MET_HEIGHT,
        T.MEASURE_DATUM_REP,
        T.MEASURE_PUP_ALGN,
        T.MEASURE_POS_REP,
        T.MEASURE_POS_VER,
        T.TASK_PARK_FPUS,
    ])

    if not rig.measure_fpuset: # pylint: disable=no-member
        # no measurements, we remove all related tasks
        print("No FPUs in measurement set, removing all measurement tasks")
        tasks -= measurement_tasks

    if opts.mockup or (not (tasks & measurement_tasks)):
        lctrl = hwsimulation.lampController()
    else:
        if opts.manual_lamp_control:
            lctrl = real_hw.manualLampController()
        else:
            lctrl = real_hw.lampController()

            # make sure that lamps are switched off on program exit
            def lamps_off():
                lctrl.switch_all_off()

            atexit.register(lamps_off)


    rig.lctrl = lctrl

    if opts.expand_tasks:
        print("Expanded tasks: %s" % list(tasks))
        sys.exit(0)

    if T.TST_GATEWAY_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_GATEWAY_CONNECTION)
        check_connection(opts, "gateway", opts.gateway_address)

    if T.TST_POS_REP_CAM_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_POS_REP_CAM_CONNECTION)
        if opts.mockup:
            print ("skipping test...")
        else:
            check_connection(
                opts, "positional repeatability camera", POS_REP_CAMERA_IP_ADDRESS
            )

    if T.TST_MET_CAL_CAM_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_MET_CAL_CAM_CONNECTION)
        if opts.mockup:
            print ("skipping test...")
        else:
            check_connection(
                opts, "metrology calibration camera", MET_CAL_CAMERA_IP_ADDRESS
            )

    if T.TST_MET_HEIGHT_CAM_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_MET_HEIGHT_CAM_CONNECTION)
        if opts.mockup:
            print ("skipping test...")
        else:
            check_connection(
                opts, "metrology height camera", MET_HEIGHT_CAMERA_IP_ADDRESS
            )

    if T.TST_PUP_ALGN_CAM_CONNECTION in tasks:
        print ("[%s] ###" % T.TST_PUP_ALGN_CAM_CONNECTION)
        if opts.mockup:
            print ("skipping test...")
        else:
            check_connection(
                opts, "pupil alignment camera", PUP_ALGN_CAMERA_IP_ADDRESS
            )

    if T.TASK_INIT_RD in tasks:

        print ("[initialize unprotected FPU driver] ###")

        rd, grid_state = init_driver(opts, max(measure_fpuset), protected=False)

        rig.grid_state = grid_state

    if T.TST_CAN_CONNECTION in tasks:
        print ("[test_can_connection] ###")
        for fpu_id in range(opts.N):
            rv = check_can_connection(rd, grid_state, opts, fpu_id)

    if T.TST_FLASH in tasks:
        print ("[flash_snum] ###")
        check_sns_unique(rig, dbe)
        flashed_numbers = []
        for fpu_id in measure_fpuset:
            serial_number = fpu_config[fpu_id]["serialnumber"]

            print (
                "flashing FPU #%i with serial number %r ... " % (fpu_id, serial_number),
                end='',
            )
            flush()
            rval = rd.writeSerialNumber(fpu_id, serial_number, grid_state)
            flashed_numbers.append(serial_number)
            print (rval)
            rd.readSerialNumbers(grid_state)
        # we update the set of FPUs which are in the database,
        # so that we can iterate over existing data when generating reports.
        add_sns_to_set(dbe, flashed_numbers)




    if T.TST_INITPOS in tasks:
        print ("[init_positions] ###")

        for fpu_id in measure_fpuset:
            alpha_start, beta_start = fpu_config[fpu_id]["pos"]
            serialnumber = fpu_config[fpu_id]["serialnumber"]

            init_position(
                dbe,
                fpu_id,
                serialnumber,
                alpha_start,
                beta_start,
            )

    # switch to protected driver instance, if needed

    if T.TASK_INIT_GD in tasks:

        if locals().has_key("rd"):
            del rd  # delete raw (unprotected) driver instance

        print ("[initialize protected driver] ###")
        gd, grid_state = init_driver(opts, max(measure_fpuset), env=env, protected=True)
        gd.readSerialNumbers(grid_state)

        rig.gd = gd
        rig.grid_state = grid_state

        for fpu_id in measure_fpuset:
            actual_sn = grid_state.FPU[fpu_id].serial_number
            configured_sn = fpu_config[fpu_id]["serialnumber"]
            if configured_sn != actual_sn:
                raise ValueError(
                    "actual serial number of FPU %i = %r does not match configuration (%r)"
                    % (fpu_id, actual_sn, configured_sn)
                )

    if opts.resetFPUs:
        print ("resetting FPUs.... ", end='')
        flush()
        gd.resetFPUs(grid_state, fpuset=measure_fpuset)
        print ("OK")

    if T.TASK_REWIND_FPUS in tasks:
        print ("[%s] ###" % T.TASK_REWIND_FPUS)

        print ("rewinding FPUs near datum position..." )

        rewind_fpus(rig, REWIND_POS_ALPHA, REWIND_POS_BETA)

    if T.TST_DATUM_ALPHA in tasks:
        print ("[%s] ###" % T.TST_DATUM_ALPHA)

        # We can use grid_state to display the starting position
        print (
            "the starting position (in degrees) is:",
            gd.trackedAngles(grid_state, retrieve=True),
        )
        test_datum(
            rig, dbe, DASEL_ALPHA
        )

    if T.TST_DATUM_BETA in tasks:
        print ("[%s] ###" % T.TST_DATUM_BETA)

        # We can use grid_state to display the starting position
        print (
            "the starting position (in degrees) is:",
            gd.trackedAngles(grid_state, retrieve=True),
        )
        test_datum(
            rig, dbe, DASEL_BETA
        )

    if T.TST_DATUM_BOTH in tasks:
        print ("[%s] ###" % T.TST_DATUM_BOTH)

        # We can use grid_state to display the starting position
        print (
            "the starting position (in degrees) is:",
            gd.trackedAngles(grid_state, retrieve=True),
        )
        test_datum(
            rig, dbe, DASEL_BOTH
        )

    if T.TASK_REFERENCE in tasks:
        print ("[%s] ###" % T.TASK_REFERENCE)
        # move all fpus to datum which are not there
        # (this is needed to operate the turntable)

        find_datum(gd, grid_state, opts=opts, uninitialized=True)

    if T.TASK_SELFTEST_NONFIBRE in tasks:
        print ("[%s] ###" % T.TASK_SELFTEST_NONFIBRE)
        selftest_nonfibre(rig,
            POS_REP_MEASUREMENT_PARS=POS_REP_MEASUREMENT_PARS,
            MET_HEIGHT_MEASUREMENT_PARS=MET_HEIGHT_MEASUREMENT_PARS,
            MET_HEIGHT_ANALYSIS_PARS=MET_HEIGHT_ANALYSIS_PARS,
            POS_REP_ANALYSIS_PARS=POS_REP_ANALYSIS_PARS,
        )

    if T.TASK_SELFTEST_FIBRE in tasks:
        print ("[%s] ###" % T.TASK_SELFTEST_FIBRE)
        selftest_fibre(
            rig,
            MET_CAL_MEASUREMENT_PARS=MET_CAL_MEASUREMENT_PARS,
            MET_CAL_TARGET_ANALYSIS_PARS=MET_CAL_TARGET_ANALYSIS_PARS,
            MET_CAL_FIBRE_ANALYSIS_PARS=MET_CAL_FIBRE_ANALYSIS_PARS,
            PUP_ALGN_MEASUREMENT_PARS=PUP_ALGN_MEASUREMENT_PARS,
            PUP_ALGN_ANALYSIS_PARS=PUP_ALGN_ANALYSIS_PARS,
        )

    if T.TST_COLLDETECT in tasks:
        print ("[test_collision_detection] ###")
        test_limit(
            rig, dbe,
            "beta_collision",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.TST_ALPHA_MIN in tasks:
        print ("[test_limit_alpha_min] ###")
        test_limit(
            rig, dbe,
            "alpha_min",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.TST_ALPHA_MAX in tasks:
        print ("[test_limit_alpha_max] ###")
        test_limit(
            rig, dbe,
            "alpha_max",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.TST_BETA_MAX in tasks:
        print ("[test_limit_beta_max] ###")
        test_limit(
            rig, dbe,
            "beta_max",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.TST_BETA_MIN in tasks:
        print ("[test_limit_beta_min] ###")
        test_limit(
            rig, dbe,
            "beta_min",
            pars=COLLDECT_MEASUREMENT_PARS
        )

    if T.MEASURE_MET_CAL in tasks:
        print ("[%s] ###" % T.MEASURE_MET_CAL)
        measure_metrology_calibration(
            rig, dbe,
            pars=MET_CAL_MEASUREMENT_PARS
        )
    if T.EVAL_MET_CAL in tasks:
        print ("[%s] ###" % T.EVAL_MET_CAL)
        eval_metrology_calibration(
            dbe,
            MET_CAL_TARGET_ANALYSIS_PARS,
            MET_CAL_FIBRE_ANALYSIS_PARS,
        )

    if T.MEASURE_MET_HEIGHT in tasks:
        print ("[%s] ###" % T.MEASURE_MET_HEIGHT)
        measure_metrology_height(
            rig, dbe,
            pars=MET_HEIGHT_MEASUREMENT_PARS
        )

    if T.EVAL_MET_HEIGHT in tasks:
        print ("[%s] ###" % T.EVAL_MET_HEIGHT)
        eval_metrology_height(
            dbe,
            MET_HEIGHT_ANALYSIS_PARS,
            MET_HEIGHT_EVALUATION_PARS,
        )

    if T.MEASURE_DATUM_REP in tasks:
        print ("[%s] ###" % T.MEASURE_DATUM_REP)
        measure_datum_repeatability(
            rig, dbe,
            pars=DATUM_REP_MEASUREMENT_PARS
        )

    if T.EVAL_DATUM_REP in tasks:
        print ("[%s] ###" % T.EVAL_DATUM_REP)
        eval_datum_repeatability(
            dbe,
            DATUM_REP_ANALYSIS_PARS,
        )

    if T.MEASURE_PUP_ALGN in tasks:
        print ("[%s] ###" % T.MEASURE_PUP_ALGN)
        measure_pupil_alignment(
            rig, dbe,
            pars=PUP_ALGN_MEASUREMENT_PARS
        )
    if T.EVAL_PUP_ALGN in tasks:
        print ("[%s] ###" % T.EVAL_PUP_ALGN)
        eval_pupil_alignment(
            dbe,
            PUP_ALGN_ANALYSIS_PARS=PUP_ALGN_ANALYSIS_PARS,
            PUP_ALGN_EVALUATION_PARS=PUP_ALGN_EVALUATION_PARS
        )

    if T.MEASURE_POS_REP in tasks:
        print ("[%s] ###" % T.MEASURE_POS_REP)
        measure_positional_repeatability(
            rig, dbe,
            pars=POS_REP_MEASUREMENT_PARS
        )

    if T.EVAL_POS_REP in tasks:
        print ("[%s] ###" % T.EVAL_POS_REP)
        eval_positional_repeatability(
            dbe,
            POS_REP_ANALYSIS_PARS,
            POS_REP_EVALUATION_PARS,
        )

    if T.MEASURE_POS_VER in tasks:
        print ("[%s] ###" % T.MEASURE_POS_VER)
        measure_positional_verification(
            rig, dbe,
            pars=POS_VER_MEASUREMENT_PARS
        )

    if T.TASK_PARK_FPUS in tasks:
        print ("[%s] ###" % T.TASK_PARK_FPUS)
        # move all fpus back to datum
        find_datum(gd, grid_state, opts=opts, uninitialized=True)

    if T.EVAL_POS_VER in tasks:
        print ("[%s] ###" % T.EVAL_POS_VER)
        eval_positional_verification(
            dbe,
            POS_REP_ANALYSIS_PARS,
            POS_VER_EVALUATION_PARS,
        )

    if T.TASK_REPORT in tasks:
        print ("[%s] ###" % T.TASK_REPORT)
        report(dbe, opts)

    if T.TASK_DUMP in tasks:
        print ("[%s] ###" % T.TASK_DUMP)
        dump_data(dbe)
